# AUTHENTICATION TYPES - BASIC, SESSION, JWT

Authentication is the process of verifying a user's or actor's identity to confirm who they claim to be. Authentication is simply answering: _Are you who you claim you are?_  
This process is necessary before granting access to protected resources. Authorization on the other hand determines the user's or actor's permissions on the resource (read, create, update, etc)  
There are several methods of authentication in the server, but I'll focus on these:

1.  **Basic Authentication**
2.  **Session Based Authentication**
3.  **JWT(JSON Web Token)**

## Basic Authentication

The idea behind basic auth is simple, send your password and username every time you make a request to the server. The server uses the database to verify the credentials before sending the response. This process is easy to implement and still keeps the requests stateless.

### The Flow

1. Client sends a request with an `Authorization` header. The header value is encoded in Base64.

```
Authorization: Basic bGFycnk6c2VjdXJlcGFzcw==
```

2. The server decodes the credentials from the header. It then verifies the data given against a database. If the credentials are valid, then it will return the resource requested.

![Basic Auth Flow](./basicauth.png "Basic Auth Flow")

This is an implementation of the authentication with FastApi

```python
from fastapi import FastAPI, HTTPException, status, Request
import base64

app = FastAPI()
def fetch_from_db():
    username = 'larry'
    password='securepass'
    print('fetching data from db')
    return username, password

@app.get("/")
def read_root(request: Request):
    auth = request.headers.get("Authorization")
    if not auth or not auth.startswith("Basic "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing or invalid Authorization header",
            headers={"WWW-Authenticate": "Basic"}, #tells the browser to prompt for credentials
        )

    #splitting and decoding the auth
    encoded_creds = auth.split(" ")[1]
    decoded = base64.b64decode(encoded_creds).decode("utf-8")
    username, password = decoded.split(':')

    _username, _pass = fetch_from_db()

    if username != _username or password != _pass:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Basic"}
        )



    return {"message": f"Hello, {username}!\n"}
```

If we use curl, we can see what happens when we make a request. Curl automatically encodes the credentials when we use the `-u` option:

```bash
$ curl localhost:8000
{"detail":"Missing or invalid Authorization header"}

$ curl -u larry:notmypass localhost:8000
{"detail":"Invalid credentials"}

$ curl -v -u larry:securepass localhost:8000
*   Trying 127.0.0.1:8000...
* Connected to localhost (127.0.0.1) port 8000 (#0)
* Server auth using Basic with user 'larry'
> GET / HTTP/1.1
> Host: localhost:8000
> Authorization: Basic bGFycnk6c2VjdXJlcGFzcw==
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< date: Wed, 12 Nov 2025 12:44:29 GMT
< server: uvicorn
< content-length: 29
< content-type: application/json
<
* Connection #0 to host localhost left intact
{"message":"Hello, larry!\n"}
```

On the last request, we can see that the credentials are encoded to `bGFycnk6c2VjdXJlcGFzcw==`

### Pros

1. **Simple:** The implementation is easy.
2. **Stateless:** The server does not need to remember who you are.

### Cons

1. **Insecure:** The credentials are encoded, not encrypted. Therefore anyone who gets them can just use decode and use them. Therefore HTTPS is needed to prevent interception. But malicious scripts may still be used.
2. **Network overhead:** The server has to make trips to the server every time a request is made. This may be expensive for a server handling many request.
3. **Difficult to revoke access:** If credentials are stolen, the user needs to change their password.

Basic auth is best for simple or internal use cases, IOT, over HTTPS and in a controlled environments

## SESSION BASED AUTHENTICATION

Session based authentication uses a unique identifier generated by the server when a user logs in. The token is stored in a database or an in memory cache like Redis. This ensures that a user's login is tracked across multiple requests.

### How it works

1. **Login:** A user/actor sends a login request with their credentials
2. **Verification and session creation:** Server verifies the credentials, creates a session. It then stores the details of the session such as user id and expiration in a db.
3. **Token issuance:** The server sends the user the session ID, typically via a cookie.
4. **Session validation:** On subsequent requests, the user will use the session ID which the server will verify against the sesion DB.

![Session Based Auth Flow](./sessionbased.png "Session Based Auth Flow")

This is a snippet of session based authentication in action. The `TOKEN_CACHE` acts as a DB, and the session ID is sent as a json payload.

```python
from fastapi import FastAPI, HTTPException, status, Request
from pydantic import BaseModel
import secrets
import time

app = FastAPI()

TOKEN_CACHE = {}
TOKEN_EXPIRE_SECONDS = 300

class Credentials(BaseModel):
    username: str
    password: str

def fetch_from_db():
    username = 'larry'
    password='securepass'
    print('fetching data from db')
    return username, password

def verify_token(token: str):
    if token in TOKEN_CACHE:
        if TOKEN_CACHE[token].get("expiresAt") > time.time():
            return TOKEN_CACHE[token]
        else:
            del TOKEN_CACHE[token]
    return False

@app.post("/login")
def login(credentials: Credentials):
    username, password = fetch_from_db()
    if credentials.username != username or credentials.password != password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="invalid credentials"
        )
    token = secrets.token_hex(16)
    TOKEN_CACHE[token] = {
        "username": username,
        "createdAt": time.time(),
        "expiresAt": time.time() + TOKEN_EXPIRE_SECONDS
        }

    return {"access_token": token, "token_type": "bearer", "expires_in": TOKEN_EXPIRE_SECONDS}

@app.get("/protected")
def protected(request: Request):
    auth = request.headers.get("Authorization")
    if not auth or not auth.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing or invalid Authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )
    token = auth.split(" ")[1]
    user_details = verify_token(token)
    if not user_details:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    print(user_details)
    return {"message": f"Hello {user_details.get('username')}!"}
```

```bash
$ curl localhost:8000/protected
{"detail":"Missing or invalid Authorization header"}

curl localhost:8000/login -H "Content-Type: application/json" -d '{"username":"larry","password":"securepass"}'
{"access_token":"8045a7461c1f68ecb8f43114d413f93c","token_type":"bearer","expires_in":300}

$ curl -H "Authorization: Bearer 8045a7461c1f68ecb8f43114d413f93c" localhost:8000/protected
{"message":"Hello larry!"}
```

Session based authentication is stateful. It is based on creating a state that represents the login sessions of the user. It is also safer than basic auth since the session token can be easily revoked.

### PROS

1. **Revocable:** It is simple to revoke the tokens as they are just deleted from the database
2. **Supports expiry**

### CONS

1. **Scalability issues:** is hard especially if the sessions are stored in the servers memory and not a shared memory or database
2. **Server load:** Opaque tokens, which are the session ids are meaningless, so the server has to make a lookup to validate them.

Session based storage is good when you need to track the sessions of a user across requests. You can also limit the number of sessions hence you have more control of user activity. For example, you can limit the number of mobile phones connected to your social media platform to three. Then delete the oldest session when a new session is created.

## JSON Web Tokens - JWT

JWT is a compact, self contained token used to authenticate users/actors. It is self contained since all data needed for authentication is contained in the json token itself. Therefore no requests to the database are made.  
JWT are are generated and verified using math. The token has three parts.

1. **Header** — specifies the signing algorithm and token type
2. **Payload** — contains the claims (e.g., user data, expiry time)
3. **Signature** — verifies that the token hasn’t been modified

These are encoded in `base64url` format separated with a `.`.
For example:

```js
{
  "alg": "HS256",  //header
  "typ": "JWT"
}
{
  "sub": "1234567890",  //payload
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}

//jwt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
```

JWT, like session based authentication use the `bearer` token scheme. This make the requests similar for both. Just how the server acts is different.

> `Bearer` authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens. The name “Bearer authentication” can be understood as “give access to the bearer of this token.”

### How It Works

1. **Log In:** The user logs in using their credentials.
2. **Verification and token issuance:** Server verifies the user against the database. If valid, it creates a JWT which will then be sent to the user.
3. **Request:** Subsequent requests to the server will include the token for authentication
4. **Verifications and response:** The token is verified by the server, without hitting the database. If valid, the resource is sent.

![JWT Auth Flow](./jwtauthflow.png "JWT Auth Flow")

Since requests are similar to session based authentication, I will just implement how the JWT is created and verified.

```python
import base64
import json
import hmac
import hashlib
import time

EXPIRY_TIME = 60
SECRET_KEY='superdupersecretkey'

def base64url_encode(data: bytes)->str:
    '''JWT encoding does not use the padding so we get rid of it'''
    return base64.urlsafe_b64encode(data).decode().rstrip('=')

def base64url_decode(data: str)-> bytes:
    '''not necessary to add padding but in strict decoders its needed
        padding ensures the string is divisible by 4
    '''
    padding = '=' * (4 - (len(data) % 4))
    return base64.urlsafe_b64decode((data + padding))

def create_jwt(payload)--> str:
    header = {'alg': "HS256", "type": "JWT"}

    header_b64 = base64url_encode(json.dumps(header).encode())
    payload_b64 = base64url_encode(json.dumps(payload).encode())

    msg = f'{header_b64}.{payload_b64}'.encode()


    signature = hmac.new(SECRET_KEY.encode(), msg, hashlib.sha256).digest() #signature is created

    signature_b64 = base64url_encode(signature)
    return f'{header_b64}.{payload_b64}.{signature_b64}'

def jwt_verify(token: str)-> bool:
    try:
        header_b64, payload_b64, signature_b64 = token.split('.')
    except ValueError:
        raise ValueError("Invalid token format")

    msg = f"{header_b64}.{payload_b64}".encode()
    signature = hmac.new(SECRET_KEY.encode(), msg, hashlib.sha256).digest()
    expected_signature = base64url_encode(signature)

    return hmac.compare_digest(expected_signature, signature_b64)


payload = {
    'user_id': 1212,
    'email': 'larry@gmail.com',
    'exp': time.time() + EXPIRY_TIME
}

jwt = create_jwt(payload)
print(jwt)
print(jwt_verify(jwt))
```

```bash
$ python3 jwtauth.py
eyJhbGciOiAiSFMyNTYiLCAidHlwZSI6ICJKV1QifQ.eyJ1c2VyX2lkIjogMTIxMiwgImVtYWlsIjogImxhcnJ5QGdtYWlsLmNvbSIsICJleHAiOiAxNzYzMDQ2MTY4LjU5MDg2MDF9.yQxCJ7R3X2NXK9pTU7sgeRriRYJOmafupZlrsIsQtyc
True
```

The snippet is just a simple implementation of how JWT is created and verified.  
But why is JWT efficient and safe? **Cryptographic signing:** When a claim is created, a signature is also created for the claim, and header using math. This example uses the HS256 algorithm, though RS256 can also be used. This depends on what you want to use the keys for When a request is made with the token, the server verifies it using the same math.  
JWT tokens cannot be changed, because the signature produced is different claims is unique. Unless one possesses the secret key.

### PROS

1. **Self-contained and efficient:** The claims on the token can be used by the server for authentication and authorization without hitting the database.
2. **Stateless:** Since all data is in the token, no session storage is needed
3. **Tamper Proof:** The signed token cannot be changed as it will fail verification

### CONS

1. **Hard to revoke:** If a token is stolen, it is valid until its expiry. This is unless it is blacklisted.
2. **Large size:** If not carefully made, the JWT may have too many claims which increases network overhead.
3. **Security:** Including sensitive claims to the JWT is not safe. Also, improper storage methods can expose the JWT.

JWT makes it simple to authenticate and authorize users in a quick and simple way. The method is also stateless which makes it easy to scale.

## SUMMARY

The authentication type to be used depends on the system needs.

Also note the following best security practices:

> 1.  It also important to note that without `HTTPS`, the tokens can be intercepted and exploited.
> 2.  For client side storage, do not use `localstorage` or plain `cookies` as tokens can be stolen using XSS by malicious extensions or scripts. Use `httponly cookie` which cannot be accessed by JS.
> 3.  Always validate algorithms when decoding JWTs.
> 4.  Use short expiry for tokens, especially JWT and a rotating secret key.

This is a summary of their features.

| Auth Type | Stateful? | Revocable? | Common Use  | Security             |
| --------- | --------- | ---------- | ----------- | -------------------- |
| Basic     | No        | No         | Simple APIs | Low                  |
| Session   | Yes       | Yes        | Web apps    | Medium               |
| JWT       | No        | Hard       | APIs, SPAs  | High (if done right) |

## REFERENCES

1. **MDN Web Docs – HTTP Authentication**  
   https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication  
   _(Detailed explanation of Basic Authentication and how the `Authorization` header works.)_

2. **RFC 7617 – The 'Basic' HTTP Authentication Scheme**  
   https://datatracker.ietf.org/doc/html/rfc7617  
   _(The official specification for Basic HTTP Authentication.)_
3. **RFC 7519 – JSON Web Token (JWT)**  
   https://datatracker.ietf.org/doc/html/rfc7519  
   _(The official specification that defines JWT structure and signing.)_

4. **Auth0 Blog – Session vs Token Authentication**  
   https://auth0.com/blog/cookies-vs-tokens-definitive-guide/  
   _(A clear, practical explanation comparing sessions, tokens, and cookies.)_

5. **JWT.io – Introduction to JSON Web Tokens**  
   https://jwt.io/introduction/  
   _(A beginner-friendly introduction and visual explanation of JWT structure and usage.)_
